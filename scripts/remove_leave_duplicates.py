# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
import asyncio
from uuid import UUID

import click
import httpx
import structlog.stdlib
from more_itertools import bucket
from more_itertools import first
from more_itertools import last
from more_itertools import one
from pydantic.main import BaseModel

from scripts.common import get_gql_client
from sdtoolplus.autogenerated_graphql_client import GraphQLClient
from sdtoolplus.autogenerated_graphql_client import LeaveFilter

logger = structlog.stdlib.get_logger()


class Leave(BaseModel):
    leave_uuid: UUID
    user_key: str
    eng_uuid: UUID


async def sync_engagement(
    eng_uuid: UUID,
) -> None:
    logger.info("Syncing engagement", eng_uuid=str(eng_uuid))

    r = httpx.post(
        "http://localhost:8000/events/mo/engagement",
        json={
            "subject": str(eng_uuid),
            "priority": 9000,
        },
    )
    try:
        r.raise_for_status()
    except httpx.HTTPStatusError as error:
        logger.info("Error calling sync endpoint", error=error, msg=r.text)
        raise error


async def remove_duplicate_leaves(
    gql_client: GraphQLClient, institution_identifier: str, dry_run: bool
) -> None:
    r_leaves = await gql_client.get_leave(LeaveFilter(from_date=None, to_date=None))

    leave_buckets = bucket(
        (
            Leave(
                leave_uuid=obj.uuid,
                user_key=user_key,
                eng_uuid=first(obj.validities).engagement_uuid,
            )
            for obj in r_leaves.objects
            if (
                user_key := one(set(validity.user_key for validity in obj.validities))
            ).startswith(institution_identifier)
        ),
        key=lambda leave_: leave_.user_key,
    )

    for user_key in leave_buckets:
        leaves = leave_buckets[user_key]
        leave_to_keep, *leaves_to_delete = leaves

        # Also remove leave where the user_key is UUID-like
        try:
            UUID(last(leave_to_keep.user_key.split("-", maxsplit=1)))
            leaves_to_delete.append(leave_to_keep)
        except ValueError:
            pass

        logger.info(
            "Processing leaves",
            leave_to_keep=leave_to_keep.dict(),
            leaves_to_delete=[leave_.dict() for leave_ in leaves_to_delete],
        )

        for leave in leaves_to_delete:
            logger.info("Delete leave", leave=leave.dict())
            if not dry_run:
                await gql_client.delete_org_function(leave.leave_uuid)

        if leaves_to_delete and not dry_run:
            await sync_engagement(leave_to_keep.eng_uuid)


@click.command()
@click.option("--institution-identifier", required=True)
@click.option("--dry-run", is_flag=True)
def main(institution_identifier: str, dry_run: bool) -> None:
    logger.info("Script started")

    gql_client = get_gql_client()
    asyncio.run(remove_duplicate_leaves(gql_client, institution_identifier, dry_run))

    logger.info("Script finished")


if __name__ == "__main__":
    main()
