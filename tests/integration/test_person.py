# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
from datetime import date
from datetime import datetime
from datetime import time
from typing import cast
from uuid import UUID
from uuid import uuid4
from zoneinfo import ZoneInfo

import pytest
from httpx import AsyncClient
from more_itertools import one
from respx import MockRouter
from time_machine import travel

from sdtoolplus.autogenerated_graphql_client import EmployeeCreateInput
from sdtoolplus.autogenerated_graphql_client import TestingCreateOrgUnitOrgUnitCreate
from sdtoolplus.autogenerated_graphql_client.input_types import AddressCreateInput
from sdtoolplus.autogenerated_graphql_client.input_types import AddressFilter
from sdtoolplus.autogenerated_graphql_client.input_types import AddressUpdateInput
from sdtoolplus.autogenerated_graphql_client.input_types import ClassFilter
from sdtoolplus.autogenerated_graphql_client.input_types import EmployeeFilter
from sdtoolplus.autogenerated_graphql_client.input_types import EngagementCreateInput
from sdtoolplus.autogenerated_graphql_client.input_types import EngagementFilter
from sdtoolplus.config import TIMEZONE
from sdtoolplus.depends import GraphQLClient
from sdtoolplus.mo.timelines.common import get_class
from sdtoolplus.mo.timelines.common import mo_end_to_timeline_end
from sdtoolplus.mo.timelines.common import timeline_interval_to_mo_validity
from sdtoolplus.mo.timelines.engagement import get_engagement_types
from sdtoolplus.models import POSITIVE_INFINITY
from sdtoolplus.models import EngType
from sdtoolplus.types import CPRNumber
from tests.integration.conftest import UNKNOWN_UNIT

CPR = CPRNumber("0101011234")

EMP_ID = "12345"
TODAY_SD_FORMAT = date.strftime(date.today(), "%Y-%m-%d")
TODAY_URL_FORMAT = date.strftime(date.today(), "%d.%m.%Y")
GETPERSON_URL = f"https://service.sd.dk/sdws/GetPerson20111201?InstitutionIdentifier=II&EffectiveDate={TODAY_URL_FORMAT}&PersonCivilRegistrationIdentifier={CPR}&StatusActiveIndicator=True&StatusPassiveIndicator=True&ContactInformationIndicator=True&PostalAddressIndicator=True"

SD_RESP = f"""<?xml version="1.0" encoding="UTF-8" ?>
    <GetPerson20111201 creationDateTime="2025-04-09T09:47:55">
        <RequestStructure>
            <InstitutionIdentifier>II</InstitutionIdentifier>
            <PersonCivilRegistrationIdentifier>0101011234</PersonCivilRegistrationIdentifier>
            <EffectiveDate>{TODAY_SD_FORMAT}</EffectiveDate>
            <StatusActiveIndicator>true</StatusActiveIndicator>
            <StatusPassiveIndicator>true</StatusPassiveIndicator>
            <ContactInformationIndicator>false</ContactInformationIndicator>
            <PostalAddressIndicator>false</PostalAddressIndicator>
        </RequestStructure>
        <Person>
            <PersonCivilRegistrationIdentifier>0101011234</PersonCivilRegistrationIdentifier>
            <PersonGivenName>Chuck</PersonGivenName>
            <PersonSurnameName>Norris</PersonSurnameName>
            <Employment>
                <EmploymentIdentifier>{EMP_ID}</EmploymentIdentifier>
            </Employment>
        </Person>
    </GetPerson20111201>
"""


@pytest.mark.integration_test
async def test_person_not_in_sd(
    test_client: AsyncClient,
    graphql_client: GraphQLClient,
    respx_mock: MockRouter,
):
    """
    We are testing the case where the person is not found in SD. We should return
    HTTP 404. Note: if the person actually exists in MO, we will not terminate the
    person in MO.
    """
    # Arrange

    cpr = "0101010101"
    get_person_url = f"https://service.sd.dk/sdws/GetPerson20111201?InstitutionIdentifier=II&EffectiveDate={TODAY_URL_FORMAT}&PersonCivilRegistrationIdentifier={cpr}&StatusActiveIndicator=True&StatusPassiveIndicator=True&ContactInformationIndicator=True&PostalAddressIndicator=True"

    respx_mock.get(get_person_url).respond(
        content_type="text/xml;charset=UTF-8",
        content="""
        <Envelope>
            <Body>
                <Fault>
                    <faultcode>soapenv:soapenvClient.ParameterError</faultcode>
                    <faultstring>
                        The stated PersonCivilRegistrationIdentifier '0101010101' does not exist.
                    </faultstring>
                    <faultactor>
                        dk.eg.sd.loen.webservices.web.sdws.BusinessHandler.qm.GetPerson20111201BO
                    </faultactor>
                    <detail>
                        <string>
                            Missing or invalid parameter from client: "The stated PersonCivilRegistrationIdentifier '0101010101' does not exist."
                        </string>
                    </detail>
                </Fault>
            </Body>
        </Envelope>
        """,
    )

    # Act
    r = await test_client.post(
        "/timeline/sync/person",
        json={
            "institution_identifier": "II",
            "cpr": cpr,
        },
    )

    # Assert
    assert r.status_code == 404


@pytest.mark.integration_test
async def test_person_create_new(
    test_client: AsyncClient,
    graphql_client: GraphQLClient,
    respx_mock: MockRouter,
):
    """
    We are testing this scenario:
    A person dosnt exist in MO and is created

    Time  -----------------------t1--------------------------------------------------->

    MO (person does not exist)

    SD (given_name)              |-----------------Chuck-------------------------------
    SD (surname)                 |-----------------Norris------------------------------
    SD (cpr)                     |-----------------0101011234--------------------------

    "Assert"                     |------------------------1----------------------------
    intervals

    NOTE: we do not actually have temporal person data in SD!
    """
    # Arrange
    tz = ZoneInfo("Europe/Copenhagen")

    t1 = datetime(1901, 1, 1, tzinfo=tz)

    # Ensure the person doesn't exist yet
    mo_person_before = await graphql_client.get_person(cpr=CPR)

    assert mo_person_before.objects == []
    respx_mock.get(GETPERSON_URL).respond(
        content_type="text/xml;charset=UTF-8",
        content=SD_RESP,
    )

    # Act
    r = await test_client.post(
        "/timeline/sync/person",
        json={
            "institution_identifier": "II",
            "cpr": CPR,
        },
    )

    # Assert
    assert r.status_code == 200

    mo_person = await graphql_client.get_person_timeline(
        EmployeeFilter(cpr_numbers=[CPR], from_date=None, to_date=None)
    )
    validity = one(one(mo_person.objects).validities)

    assert validity.validity.from_ == t1
    assert validity.validity.to is None
    assert validity.cpr_number == CPR
    assert validity.given_name == "Chuck"
    assert validity.surname == "Norris"


@pytest.mark.integration_test
async def test_person_timeline_update(
    test_client: AsyncClient,
    graphql_client: GraphQLClient,
    respx_mock: MockRouter,
):
    """
    We are testing this scenario:
    A person exists in MO but with the wrong name. Test that the name is updated in MO.

    Time  ------------t1--------t2---------------------------------------------------->

    MO (given_name)   |-------------------Buck-----------------------------------------
    MO (surname)      |-------------------Lorris---------------------------------------
    MO (cpr)          |-------------------0101011234-----------------------------------

    "Arrange"         |---------------------------1------------------------------------
    intervals

    SD (givenname)    |---Buck--|-----------------Chuck--------------------------------
    MO (surname)      |--Lorris-|-----------------Norris-------------------------------
    MO (cpr)          |-------------------0101011234-----------------------------------

    "Assert"          |----1----|------------------------2-----------------------------
    intervals

    NOTE: we do not actually have temporal person data in SD! So t2 just indicates the
          point in time where the person data is changed in SD.
    """
    # Arrange
    tz = ZoneInfo("Europe/Copenhagen")

    t1 = datetime(1901, 1, 1, tzinfo=tz)
    t2 = datetime.now(tz=tz)

    # Create person
    person_uuid = uuid4()
    await graphql_client.create_person(
        EmployeeCreateInput(
            uuid=person_uuid,
            cpr_number=CPR,
            given_name="Buck",
            surname="Lorris",
        )
    )
    respx_mock.get(GETPERSON_URL).respond(
        content_type="text/xml;charset=UTF-8",
        content=SD_RESP,
    )

    # Act
    r = await test_client.post(
        "/timeline/sync/person",
        json={
            "institution_identifier": "II",
            "cpr": CPR,
        },
    )

    # Assert
    assert r.status_code == 200

    mo_person = await graphql_client.get_person_timeline(
        EmployeeFilter(uuids=[person_uuid], from_date=None, to_date=None)
    )
    validities = one(mo_person.objects).validities

    interval_1 = validities[0]
    assert interval_1.validity.from_ == t1
    assert mo_end_to_timeline_end(interval_1.validity.to).date() == t2.date()
    assert interval_1.cpr_number == CPR
    assert interval_1.given_name == "Buck"
    assert interval_1.surname == "Lorris"

    interval_2 = validities[1]
    assert interval_2.validity.from_ is not None
    assert interval_2.validity.from_.date() == t2.date()
    assert mo_end_to_timeline_end(interval_2.validity.to) == POSITIVE_INFINITY
    assert interval_2.cpr_number == CPR
    assert interval_2.given_name == "Chuck"
    assert interval_2.surname == "Norris"

    assert len(validities) == 2


@pytest.mark.integration_test
async def test_person_skip_0000_cprs(
    test_client: AsyncClient,
    graphql_client: GraphQLClient,
):
    """
    Test that we are skipping person with CPRs ending in 0000.
    """
    # Arrange
    cpr = "0101010000"

    # Act
    r = await test_client.post(
        "/timeline/sync/person",
        json={
            "institution_identifier": "II",
            "cpr": "0101010000",
        },
    )

    # Assert
    assert r.status_code == 200

    mo_person = await graphql_client.get_person_timeline(
        EmployeeFilter(cpr_numbers=[cast(CPRNumber, cpr)], from_date=None, to_date=None)
    )

    assert not mo_person.objects


@pytest.mark.integration_test
@travel("2002-07-01")
@pytest.mark.envvar(
    {
        "MODE": "region",
        "UNKNOWN_UNIT": str(UNKNOWN_UNIT),
        "APPLY_NY_LOGIC": "false",
        "MO_SUBTREE_PATHS_FOR_ROOT": '{"II": ["12121212-1212-1212-1212-121212121212", "10000000-0000-0000-0000-000000000000"]}',
        "PREFIX_ENGAGEMENT_USER_KEYS": "true",
        "ENABLE_PERSON_ADDRESS_SYNC": "true",
    }
)
async def test_person_addresses(
    test_client: AsyncClient,
    graphql_client: GraphQLClient,
    base_tree_builder: TestingCreateOrgUnitOrgUnitCreate,
    respx_mock: MockRouter,
) -> None:
    """
    Test that person addresses are synced correctly. We test the following for
    a given person:

    Addresses in MO:
                                               Now
    Time  --------------t1--------------t2------+---------t3---------------------->

    Phone1 (no-op)      |----12345678---|----------23456789-----------------------
    Email1 (update)     |---------chuck@karate.org--------|---chuck@judo.org------
    Email2 (update)                                       |-norris@hollywood.com--
    Postal (terminate)  |-----------------Paradisæblevej 13, 1000, Andeby---------
    Postal (update)     |-----------------Paradisæblevej 13, 1000, Andeby---------

    Addresses in SD (no timelines!):
    Phone1: 23456789 (no-op)
    Phone2: 34567890 (create)
    Email1: chuck@karate.org (update)
    Email2: norris@hollywood.com (update)
    Postal: Fasanvænget 11, 2000, Gåserød (update)
    """

    # Arrange
    t1 = datetime(2001, 1, 1, tzinfo=TIMEZONE)
    t2 = datetime(2002, 1, 1, tzinfo=TIMEZONE)
    t3 = datetime(2003, 1, 1, tzinfo=TIMEZONE)

    person_uuid = uuid4()
    cpr = "0101011234"
    now = datetime.combine(datetime.today(), time.min, tzinfo=TIMEZONE)

    # Create person
    await graphql_client.create_person(
        EmployeeCreateInput(
            uuid=person_uuid,
            cpr_number=CPRNumber(cpr),
            given_name="Chuck",
            surname="Norris",
        )
    )

    # Get the address types
    phone1_address_type_uuid = await get_class(
        gql_client=graphql_client,
        facet_user_key="employee_address_type",
        class_user_key="person_telefon",
    )

    phone2_address_type_uuid = await get_class(
        gql_client=graphql_client,
        facet_user_key="employee_address_type",
        class_user_key="person_telefon_anden",
    )

    email1_address_type_uuid = await get_class(
        gql_client=graphql_client,
        facet_user_key="employee_address_type",
        class_user_key="person_email",
    )

    email2_address_type_uuid = await get_class(
        gql_client=graphql_client,
        facet_user_key="employee_address_type",
        class_user_key="person_email_anden",
    )

    postal_address_type_uuid = await get_class(
        gql_client=graphql_client,
        facet_user_key="employee_address_type",
        class_user_key="AdresseSDEmployee",
    )

    visibility_uuid = await get_class(
        gql_client=graphql_client,
        facet_user_key="visibility",
        class_user_key="Public",
    )

    # Create phone 1
    phone1_uuid = (
        await graphql_client.create_address(
            AddressCreateInput(
                person=person_uuid,
                user_key="12345678",
                value="12345678",
                address_type=phone1_address_type_uuid,
                visibility=visibility_uuid,
                validity=timeline_interval_to_mo_validity(t1, POSITIVE_INFINITY),
            )
        )
    ).uuid

    await graphql_client.update_address(
        AddressUpdateInput(
            uuid=phone1_uuid,
            person=person_uuid,
            user_key="23456789",
            value="23456789",
            address_type=phone1_address_type_uuid,
            visibility=visibility_uuid,
            validity=timeline_interval_to_mo_validity(t2, POSITIVE_INFINITY),
        )
    )

    # Create email 1
    email1_uuid = (
        await graphql_client.create_address(
            AddressCreateInput(
                person=person_uuid,
                user_key="chuck@karate.org",
                value="chuck@karate.org",
                address_type=email1_address_type_uuid,
                visibility=visibility_uuid,
                validity=timeline_interval_to_mo_validity(t1, POSITIVE_INFINITY),
            )
        )
    ).uuid

    await graphql_client.update_address(
        AddressUpdateInput(
            uuid=email1_uuid,
            person=person_uuid,
            user_key="chuck@judo.org",
            value="chuck@judo.org",
            address_type=email1_address_type_uuid,
            visibility=visibility_uuid,
            validity=timeline_interval_to_mo_validity(t3, POSITIVE_INFINITY),
        )
    )

    # Create email 2
    email2_uuid = (
        await graphql_client.create_address(
            AddressCreateInput(
                person=person_uuid,
                user_key="norris@hollywood.com",
                value="norris@hollywood.com",
                address_type=email2_address_type_uuid,
                visibility=visibility_uuid,
                validity=timeline_interval_to_mo_validity(t3, POSITIVE_INFINITY),
            )
        )
    ).uuid

    # Create postal address
    postal_address1_uuid = (
        await graphql_client.create_address(
            AddressCreateInput(
                person=person_uuid,
                user_key="Paradisæblevej 13, 1000, Andeby",
                value="Paradisæblevej 13, 1000, Andeby",
                address_type=postal_address_type_uuid,
                visibility=visibility_uuid,
                validity=timeline_interval_to_mo_validity(t1, POSITIVE_INFINITY),
            )
        )
    ).uuid

    # Create the same duplicate postal address again
    postal_address2_uuid = (
        await graphql_client.create_address(
            AddressCreateInput(
                person=person_uuid,
                user_key="Paradisæblevej 13, 1000, Andeby",
                value="Paradisæblevej 13, 1000, Andeby",
                address_type=postal_address_type_uuid,
                visibility=visibility_uuid,
                validity=timeline_interval_to_mo_validity(t1, POSITIVE_INFINITY),
            )
        )
    ).uuid

    sd_resp = f"""<?xml version="1.0" encoding="UTF-8" ?>
        <GetPerson20111201 creationDateTime="2025-04-09T09:47:55">
            <RequestStructure>
                <InstitutionIdentifier>II</InstitutionIdentifier>
                <PersonCivilRegistrationIdentifier>0101011234</PersonCivilRegistrationIdentifier>
                <EffectiveDate>2002-07-01</EffectiveDate>
                <StatusActiveIndicator>true</StatusActiveIndicator>
                <StatusPassiveIndicator>true</StatusPassiveIndicator>
                <ContactInformationIndicator>true</ContactInformationIndicator>
                <PostalAddressIndicator>true</PostalAddressIndicator>
            </RequestStructure>
            <Person>
                <PersonCivilRegistrationIdentifier>{cpr}</PersonCivilRegistrationIdentifier>
                <PersonGivenName>Chuck</PersonGivenName>
                <PersonSurnameName>Norris</PersonSurnameName>
                <PostalAddress>
                    <StandardAddressIdentifier>Fasanvænget 11</StandardAddressIdentifier>
                    <PostalCode>2000</PostalCode>
                    <DistrictName>Gåserød</DistrictName>
                    <MunicipalityCode>1234</MunicipalityCode>
                    <CountryIdentificationCode scheme="iso3166-alpha2">DK</CountryIdentificationCode>
                </PostalAddress>
                <ContactInformation>
                    <TelephoneNumberIdentifier>23456789</TelephoneNumberIdentifier>
                    <TelephoneNumberIdentifier>34567890</TelephoneNumberIdentifier>
                    <EmailAddressIdentifier>chuck@karate.org</EmailAddressIdentifier>
                    <EmailAddressIdentifier>norris@hollywood.com</EmailAddressIdentifier>
                </ContactInformation>
                <Employment>
                    <EmploymentIdentifier>12345</EmploymentIdentifier>
                </Employment>
            </Person>
        </GetPerson20111201>
    """
    respx_mock.get(
        f"https://service.sd.dk/sdws/GetPerson20111201?InstitutionIdentifier=II&EffectiveDate=01.07.2002&PersonCivilRegistrationIdentifier={cpr}&StatusActiveIndicator=True&StatusPassiveIndicator=True&ContactInformationIndicator=True&PostalAddressIndicator=True"
    ).respond(
        content_type="text/xml;charset=UTF-8",
        content=sd_resp,
    )

    # Act
    r = await test_client.post(
        "/timeline/sync/person",
        json={
            "institution_identifier": "II",
            "cpr": cpr,
        },
    )

    # Assert
    assert r.status_code == 200

    # Phone 1
    r_phone1 = await graphql_client.get_address_timeline(
        input=AddressFilter(
            employee=EmployeeFilter(uuids=[person_uuid]),
            address_type=ClassFilter(uuids=[phone1_address_type_uuid]),
            from_date=None,
            to_date=None,
        )
    )

    phone1 = one(r_phone1.objects)

    interval_1 = phone1.validities[0]
    assert phone1.uuid == phone1_uuid
    assert interval_1.validity.from_ == t1
    assert mo_end_to_timeline_end(interval_1.validity.to) == t2
    assert interval_1.user_key == "12345678"
    assert interval_1.value == "12345678"
    assert interval_1.visibility_uuid == visibility_uuid
    assert interval_1.address_type.uuid == phone1_address_type_uuid

    interval_2 = phone1.validities[1]
    assert interval_2.validity.from_ == t2
    assert mo_end_to_timeline_end(interval_2.validity.to) == POSITIVE_INFINITY
    assert interval_2.user_key == "23456789"
    assert interval_2.value == "23456789"
    assert interval_2.visibility_uuid == visibility_uuid
    assert interval_2.address_type.uuid == phone1_address_type_uuid

    assert len(phone1.validities) == 2

    # Phone 2
    r_phone2 = await graphql_client.get_address_timeline(
        input=AddressFilter(
            employee=EmployeeFilter(uuids=[person_uuid]),
            address_type=ClassFilter(uuids=[phone2_address_type_uuid]),
            from_date=None,
            to_date=None,
        )
    )

    phone2 = one(r_phone2.objects)

    interval_1 = one(phone2.validities)
    assert interval_1.validity.from_ == now
    assert mo_end_to_timeline_end(interval_1.validity.to) == POSITIVE_INFINITY
    assert interval_1.user_key == "34567890"
    assert interval_1.value == "34567890"
    assert interval_1.visibility_uuid == visibility_uuid
    assert interval_1.address_type.uuid == phone2_address_type_uuid

    # Email 1
    r_email1 = await graphql_client.get_address_timeline(
        input=AddressFilter(
            employee=EmployeeFilter(uuids=[person_uuid]),
            address_type=ClassFilter(uuids=[email1_address_type_uuid]),
            from_date=None,
            to_date=None,
        )
    )

    email1 = one(r_email1.objects)

    interval_1 = one(email1.validities)
    assert email1.uuid == email1_uuid
    assert interval_1.validity.from_ == t1
    assert mo_end_to_timeline_end(interval_1.validity.to) == POSITIVE_INFINITY
    assert interval_1.user_key == "chuck@karate.org"
    assert interval_1.value == "chuck@karate.org"
    assert interval_1.visibility_uuid == visibility_uuid
    assert interval_1.address_type.uuid == email1_address_type_uuid

    # Email 2
    r_email2 = await graphql_client.get_address_timeline(
        input=AddressFilter(
            employee=EmployeeFilter(uuids=[person_uuid]),
            address_type=ClassFilter(uuids=[email2_address_type_uuid]),
            from_date=None,
            to_date=None,
        )
    )

    email2 = one(r_email2.objects)

    interval_1 = one(email2.validities)
    assert email2.uuid == email2_uuid
    assert interval_1.validity.from_ == now
    assert mo_end_to_timeline_end(interval_1.validity.to) == POSITIVE_INFINITY
    assert interval_1.user_key == "norris@hollywood.com"
    assert interval_1.value == "norris@hollywood.com"
    assert interval_1.visibility_uuid == visibility_uuid
    assert interval_1.address_type.uuid == email2_address_type_uuid

    # Postal address
    r_postal_address = await graphql_client.get_address_timeline(
        input=AddressFilter(
            employee=EmployeeFilter(uuids=[person_uuid]),
            address_type=ClassFilter(uuids=[postal_address_type_uuid]),
            from_date=now,
            to_date=None,
        )
    )

    postal_address = one(r_postal_address.objects)

    interval_1 = one(postal_address.validities)
    assert postal_address.uuid in (postal_address1_uuid, postal_address2_uuid)
    assert interval_1.validity.from_ == now
    assert mo_end_to_timeline_end(interval_1.validity.to) == POSITIVE_INFINITY
    assert interval_1.user_key == "Fasanvænget 11, 2000, Gåserød"
    assert interval_1.value == "Fasanvænget 11, 2000, Gåserød"
    assert interval_1.visibility_uuid == visibility_uuid
    assert interval_1.address_type.uuid == postal_address_type_uuid


@pytest.mark.integration_test
@travel("2002-07-01")
@pytest.mark.envvar(
    {
        "MODE": "region",
        "UNKNOWN_UNIT": str(UNKNOWN_UNIT),
        "APPLY_NY_LOGIC": "false",
        "MO_SUBTREE_PATHS_FOR_ROOT": '{"II": ["12121212-1212-1212-1212-121212121212", "10000000-0000-0000-0000-000000000000"]}',
        "PREFIX_ENGAGEMENT_USER_KEYS": "true",
        "ENABLE_PERSON_ADDRESS_SYNC": "true",
    }
)
async def test_person_engagement_addresses(
    test_client: AsyncClient,
    graphql_client: GraphQLClient,
    base_tree_builder: TestingCreateOrgUnitOrgUnitCreate,
    job_function_1234: UUID,
    respx_mock: MockRouter,
) -> None:
    """
    Test that person *engagement* addresses are synced correctly.
    We test the following for a given person:

    Addresses in MO:
                                               Now
    Time  --------------t1--------------t2------+---------t3---------------------->

    Phone1 (no-op)      |----12345678---|----------23456789-----------------------
    Email1 (update)     |---------chuck@karate.org--------|---chuck@judo.org------
    Email2 (update)                                       |-norris@hollywood.com--

    Addresses in SD (no timelines!):
    Phone1: 23456789 (no-op)
    Phone2: 34567890 (create)
    Email1: chuck@karate.org (update)
    Email2: norris@hollywood.com (update)
    """

    # Arrange
    t1 = datetime(2001, 1, 1, tzinfo=TIMEZONE)
    t2 = datetime(2002, 1, 1, tzinfo=TIMEZONE)
    t3 = datetime(2003, 1, 1, tzinfo=TIMEZONE)

    person_uuid = uuid4()
    cpr = "0101011234"
    emp_id = "12345"
    now = datetime.combine(datetime.today(), time.min, tzinfo=TIMEZONE)

    dep1_uuid = UUID("10000000-0000-0000-0000-000000000000")

    # Create person
    await graphql_client.create_person(
        EmployeeCreateInput(
            uuid=person_uuid,
            cpr_number=CPRNumber(cpr),
            given_name="Chuck",
            surname="Norris",
        )
    )

    eng_types = await get_engagement_types(graphql_client)

    # Create engagement
    eng_uuid = (
        await graphql_client.create_engagement(
            EngagementCreateInput(
                user_key=f"II-{emp_id}",
                validity=timeline_interval_to_mo_validity(t2, POSITIVE_INFINITY),
                extension_1="name4",
                extension_4="dep1",
                person=person_uuid,
                org_unit=dep1_uuid,
                engagement_type=eng_types[EngType.MONTHLY_FULL_TIME],
                job_function=job_function_1234,
            )
        )
    ).uuid

    # Get the address types
    phone1_address_type_uuid = await get_class(
        gql_client=graphql_client,
        facet_user_key="employee_address_type",
        class_user_key="engagement_telefon",
    )

    phone2_address_type_uuid = await get_class(
        gql_client=graphql_client,
        facet_user_key="employee_address_type",
        class_user_key="engagement_telefon_anden",
    )

    email1_address_type_uuid = await get_class(
        gql_client=graphql_client,
        facet_user_key="employee_address_type",
        class_user_key="engagement_email",
    )

    email2_address_type_uuid = await get_class(
        gql_client=graphql_client,
        facet_user_key="employee_address_type",
        class_user_key="engagement_email_anden",
    )

    visibility_uuid = await get_class(
        gql_client=graphql_client,
        facet_user_key="visibility",
        class_user_key="Public",
    )

    # Create phone 1
    phone1_uuid = (
        await graphql_client.create_address(
            AddressCreateInput(
                person=person_uuid,
                user_key="12345678",
                value="12345678",
                address_type=phone1_address_type_uuid,
                visibility=visibility_uuid,
                engagement=eng_uuid,
                validity=timeline_interval_to_mo_validity(t1, POSITIVE_INFINITY),
            )
        )
    ).uuid

    await graphql_client.update_address(
        AddressUpdateInput(
            uuid=phone1_uuid,
            person=person_uuid,
            user_key="23456789",
            value="23456789",
            address_type=phone1_address_type_uuid,
            visibility=visibility_uuid,
            engagement=eng_uuid,
            validity=timeline_interval_to_mo_validity(t2, POSITIVE_INFINITY),
        )
    )

    # Create email 1
    email1_uuid = (
        await graphql_client.create_address(
            AddressCreateInput(
                person=person_uuid,
                user_key="chuck@karate.org",
                value="chuck@karate.org",
                address_type=email1_address_type_uuid,
                visibility=visibility_uuid,
                engagement=eng_uuid,
                validity=timeline_interval_to_mo_validity(t1, POSITIVE_INFINITY),
            )
        )
    ).uuid

    await graphql_client.update_address(
        AddressUpdateInput(
            uuid=email1_uuid,
            person=person_uuid,
            user_key="chuck@judo.org",
            value="chuck@judo.org",
            address_type=email1_address_type_uuid,
            visibility=visibility_uuid,
            engagement=eng_uuid,
            validity=timeline_interval_to_mo_validity(t3, POSITIVE_INFINITY),
        )
    )

    # Create email 2
    email2_uuid = (
        await graphql_client.create_address(
            AddressCreateInput(
                person=person_uuid,
                user_key="norris@hollywood.com",
                value="norris@hollywood.com",
                address_type=email2_address_type_uuid,
                visibility=visibility_uuid,
                engagement=eng_uuid,
                validity=timeline_interval_to_mo_validity(t3, POSITIVE_INFINITY),
            )
        )
    ).uuid

    sd_resp = f"""<?xml version="1.0" encoding="UTF-8" ?>
        <GetPerson20111201 creationDateTime="2025-04-09T09:47:55">
            <RequestStructure>
                <InstitutionIdentifier>II</InstitutionIdentifier>
                <PersonCivilRegistrationIdentifier>0101011234</PersonCivilRegistrationIdentifier>
                <EffectiveDate>2002-07-01</EffectiveDate>
                <StatusActiveIndicator>true</StatusActiveIndicator>
                <StatusPassiveIndicator>true</StatusPassiveIndicator>
                <ContactInformationIndicator>true</ContactInformationIndicator>
                <PostalAddressIndicator>true</PostalAddressIndicator>
            </RequestStructure>
            <Person>
                <PersonCivilRegistrationIdentifier>{cpr}</PersonCivilRegistrationIdentifier>
                <PersonGivenName>Chuck</PersonGivenName>
                <PersonSurnameName>Norris</PersonSurnameName>
                <Employment>
                    <EmploymentIdentifier>{emp_id}</EmploymentIdentifier>
                    <ContactInformation>
                        <TelephoneNumberIdentifier>23456789</TelephoneNumberIdentifier>
                        <TelephoneNumberIdentifier>34567890</TelephoneNumberIdentifier>
                        <EmailAddressIdentifier>chuck@karate.org</EmailAddressIdentifier>
                        <EmailAddressIdentifier>norris@hollywood.com</EmailAddressIdentifier>
                        <EmailAddressIdentifier>ignored@hollywood.com</EmailAddressIdentifier>
                    </ContactInformation>
                </Employment>
            </Person>
        </GetPerson20111201>
    """
    respx_mock.get(
        f"https://service.sd.dk/sdws/GetPerson20111201?InstitutionIdentifier=II&EffectiveDate=01.07.2002&PersonCivilRegistrationIdentifier={cpr}&StatusActiveIndicator=True&StatusPassiveIndicator=True&ContactInformationIndicator=True&PostalAddressIndicator=True"
    ).respond(
        content_type="text/xml;charset=UTF-8",
        content=sd_resp,
    )

    # Act
    r = await test_client.post(
        "/timeline/sync/person",
        json={
            "institution_identifier": "II",
            "cpr": cpr,
        },
    )

    # Assert
    assert r.status_code == 200

    # Phone 1
    r_phone1 = await graphql_client.get_address_timeline(
        input=AddressFilter(
            employee=EmployeeFilter(uuids=[person_uuid]),
            address_type=ClassFilter(uuids=[phone1_address_type_uuid]),
            engagement=EngagementFilter(uuids=[eng_uuid]),
            from_date=None,
            to_date=None,
        )
    )

    phone1 = one(r_phone1.objects)

    interval_1 = phone1.validities[0]
    assert phone1.uuid == phone1_uuid
    assert interval_1.validity.from_ == t1
    assert mo_end_to_timeline_end(interval_1.validity.to) == t2
    assert interval_1.user_key == "12345678"
    assert interval_1.value == "12345678"
    assert interval_1.visibility_uuid == visibility_uuid
    assert interval_1.address_type.uuid == phone1_address_type_uuid

    interval_2 = phone1.validities[1]
    assert interval_2.validity.from_ == t2
    assert mo_end_to_timeline_end(interval_2.validity.to) == POSITIVE_INFINITY
    assert interval_2.user_key == "23456789"
    assert interval_2.value == "23456789"
    assert interval_2.visibility_uuid == visibility_uuid
    assert interval_2.address_type.uuid == phone1_address_type_uuid

    assert len(phone1.validities) == 2

    # Phone 2
    r_phone2 = await graphql_client.get_address_timeline(
        input=AddressFilter(
            employee=EmployeeFilter(uuids=[person_uuid]),
            address_type=ClassFilter(uuids=[phone2_address_type_uuid]),
            engagement=EngagementFilter(uuids=[eng_uuid]),
            from_date=None,
            to_date=None,
        )
    )

    phone2 = one(r_phone2.objects)

    interval_1 = one(phone2.validities)
    assert interval_1.validity.from_ == now
    assert mo_end_to_timeline_end(interval_1.validity.to) == POSITIVE_INFINITY
    assert interval_1.user_key == "34567890"
    assert interval_1.value == "34567890"
    assert interval_1.visibility_uuid == visibility_uuid
    assert interval_1.address_type.uuid == phone2_address_type_uuid

    # Email 1
    r_email1 = await graphql_client.get_address_timeline(
        input=AddressFilter(
            employee=EmployeeFilter(uuids=[person_uuid]),
            address_type=ClassFilter(uuids=[email1_address_type_uuid]),
            engagement=EngagementFilter(uuids=[eng_uuid]),
            from_date=None,
            to_date=None,
        )
    )

    email1 = one(r_email1.objects)

    interval_1 = one(email1.validities)
    assert email1.uuid == email1_uuid
    assert interval_1.validity.from_ == t1
    assert mo_end_to_timeline_end(interval_1.validity.to) == POSITIVE_INFINITY
    assert interval_1.user_key == "chuck@karate.org"
    assert interval_1.value == "chuck@karate.org"
    assert interval_1.visibility_uuid == visibility_uuid
    assert interval_1.address_type.uuid == email1_address_type_uuid

    # Email 2
    r_email2 = await graphql_client.get_address_timeline(
        input=AddressFilter(
            employee=EmployeeFilter(uuids=[person_uuid]),
            address_type=ClassFilter(uuids=[email2_address_type_uuid]),
            engagement=EngagementFilter(uuids=[eng_uuid]),
            from_date=None,
            to_date=None,
        )
    )

    email2 = one(r_email2.objects)

    interval_1 = one(email2.validities)
    assert email2.uuid == email2_uuid
    assert interval_1.validity.from_ == now
    assert mo_end_to_timeline_end(interval_1.validity.to) == POSITIVE_INFINITY
    assert interval_1.user_key == "norris@hollywood.com"
    assert interval_1.value == "norris@hollywood.com"
    assert interval_1.visibility_uuid == visibility_uuid
    assert interval_1.address_type.uuid == email2_address_type_uuid
