# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
from datetime import datetime
from datetime import timedelta
from typing import cast
from uuid import UUID

import structlog
from fastramqpi.ramqp.depends import handle_exclusively_decorator
from more_itertools import bucket
from more_itertools import one
from more_itertools import only
from sdclient.client import SDClient

from sdtoolplus.autogenerated_graphql_client import AddressCreateInput
from sdtoolplus.autogenerated_graphql_client import AddressFilter
from sdtoolplus.autogenerated_graphql_client import AddressTerminateInput
from sdtoolplus.autogenerated_graphql_client import ClassFilter
from sdtoolplus.autogenerated_graphql_client import EmployeeFilter
from sdtoolplus.autogenerated_graphql_client import FacetFilter
from sdtoolplus.autogenerated_graphql_client import GetAddressTimelineAddresses
from sdtoolplus.autogenerated_graphql_client import GetPersonTimelineEmployees
from sdtoolplus.config import TIMEZONE
from sdtoolplus.depends import GraphQLClient
from sdtoolplus.exceptions import MoreThanOnePersonError
from sdtoolplus.mo.person import create_person
from sdtoolplus.mo.person import update_person
from sdtoolplus.models import Person
from sdtoolplus.sd.person import get_sd_person
from sdtoolplus.types import CPRNumber

logger = structlog.stdlib.get_logger()


async def _sync_person(
    gql_client: GraphQLClient,
    sd_person: Person,
    mo_person: GetPersonTimelineEmployees,
    dry_run: bool,
) -> None:
    mo_objects = only(mo_person.objects, too_long=MoreThanOnePersonError)
    if mo_objects is None:
        person_uuid = await create_person(
            gql_client=gql_client,
            cpr=sd_person.cpr,
            givenname=sd_person.given_name,
            lastname=sd_person.surname,
            dry_run=dry_run,
        )
    elif (
        len(mo_objects.validities) > 1
        or one(mo_objects.validities).given_name != sd_person.given_name
        or one(mo_objects.validities).surname != sd_person.surname
    ):
        person_uuid = one(mo_person.objects).uuid
        await update_person(
            gql_client=gql_client,
            uuid=person_uuid,
            start=datetime.today(),
            person=sd_person,
            dry_run=dry_run,
        )
    else:
        # No changes to person, now check addresses
        person_uuid = one(mo_person.objects).uuid
    await sync_person_addresses(
        gql_client=gql_client,
        person_uuid=person_uuid,
        sd_person=sd_person,
        dry_run=dry_run,
    )


async def sync_person_addresses(
    gql_client: GraphQLClient,
    person_uuid: UUID,
    sd_person: Person,
    dry_run: bool,
) -> None:
    """Persons are not temporal objects in SD and are handled differently than orgunits and engagements.
    In stead of the full timeline checks we only check the data from `now` to infinity.
    """
    # TODO: Cache this result as it rarely changes
    address_types_res = await gql_client.get_class(
        class_filter=ClassFilter(facet_user_keys=["employee_address_type"])
    )

    address_types = bucket(
        address_types_res.objects,
        key=lambda x: x.current.user_key if x.current else None,
    )

    desired_emails = sd_person.emails if sd_person.emails else []
    await handle_address(
        gql_client,
        desired_emails,
        person_uuid,
        one(address_types["engagement_email"]).uuid,
        dry_run,
    )
    desired_phone_numbers = (
        [phone_number for phone_number in sd_person.phone_numbers]
        if sd_person.phone_numbers
        else []
    )
    await handle_address(
        gql_client,
        desired_phone_numbers,
        person_uuid,
        one(address_types["engagement_telefon"]).uuid,
        dry_run,
    )
    desired_post_adresses = [sd_person.address] if sd_person.address else []
    # TODO: Addresses should have the scope DAR, but this is not the case everywhere right now.
    await handle_address(
        gql_client,
        desired_post_adresses,
        person_uuid,
        one(address_types["AdresseAPOSOrgUnit"]).uuid,
        dry_run,
    )


def find_address_actions(
    mo_values: GetAddressTimelineAddresses, desired_addresses: list[str]
) -> tuple[set[str], set[UUID]]:
    terminate: set[UUID] = set()
    create: set[str] = set()
    existing: set[str] = set()
    if not mo_values.objects:
        return set(desired_addresses), terminate
    for address in mo_values.objects:
        uuid = address.uuid
        # For each address check that there are only one validity,
        # that the wanted value exists in MO and in the correct timeframe
        if (
            len(address.validities) > 1
            or one(address.validities).value not in desired_addresses
            or one(address.validities).validity.from_ > datetime.now(tz=TIMEZONE)
            or one(address.validities).validity.to is not None
        ):
            # If any of the above reasons are met we terminate the address
            terminate.add(uuid)
        else:
            # If not it is because it exists in MO
            # Check for duplicates:
            if one(address.validities).value in existing:
                terminate.add(uuid)
            existing.add(one(address.validities).value)

    # Create any address from desired_addresses not in MO yet.
    create = {c for c in desired_addresses if c not in existing}
    return create, terminate


async def handle_address(
    gql_client: GraphQLClient,
    desired_addresses: list[str],
    person_uuid: UUID,
    address_type_uuid: UUID,
    dry_run: bool,
):
    mo_person_addresses = await gql_client.get_address_timeline(
        input=AddressFilter(
            employee=EmployeeFilter(uuids=[person_uuid]),
            address_type=ClassFilter(uuids=[address_type_uuid]),
            from_date=datetime.now(),
            to_date=None,
        )
    )
    create, terminate = find_address_actions(mo_person_addresses, desired_addresses)
    # TODO: cache this as it _never_ changes.
    visibility_internal = await gql_client.get_class(
        class_filter=ClassFilter(
            facet=FacetFilter(user_keys=["visibility"]), scope=["INTERNAL"]
        )
    )
    visibility_uuid = one(visibility_internal.objects).uuid

    # Check for new emails:
    for value in create:
        logger.info(
            "Create new address",
            value=value,
            person=person_uuid,
            address_type_uuid=address_type_uuid,
            dry_run=dry_run,
        )
        if not dry_run:
            await gql_client.create_address(
                input=AddressCreateInput(
                    person=person_uuid,
                    validity={"from": datetime.today(), "to": None},
                    value=value,
                    address_type=address_type_uuid,
                    visibility=visibility_uuid,
                )
            )
    # Check for removed emails
    for address_uuid in terminate:
        logger.info("terminate address", person=person_uuid, dry_run=dry_run)
        if not dry_run:
            await gql_client.terminate_address(
                AddressTerminateInput(
                    uuid=address_uuid,
                    to=datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
                    - timedelta(days=1),
                )
            )


@handle_exclusively_decorator(
    key=lambda sd_client, gql_client, institution_identifier, cpr, dry_run=False: cpr
)
async def sync_person(
    sd_client: SDClient,
    gql_client: GraphQLClient,
    institution_identifier: str,
    cpr: str,
    dry_run: bool = False,
) -> None:
    logger.info(
        "Sync person",
        inst_id=institution_identifier,
        cpr=cpr,
        dry_run=dry_run,
    )

    if cpr.endswith("0000"):
        logger.warning(
            "Skipping person since CPR ends with 0000",
            institution_identifier=institution_identifier,
            cpr=cpr,
        )
        return

    sd_person = await get_sd_person(
        sd_client=sd_client,
        institution_identifier=institution_identifier,
        cpr=cpr,
        effective_date=datetime.today(),
    )

    mo_person = await gql_client.get_person_timeline(
        filter=EmployeeFilter(
            cpr_numbers=[cast(CPRNumber, cpr)], from_date=datetime.today(), to_date=None
        )
    )
    logger.debug("MO person", mo_person=mo_person.dict())

    await _sync_person(
        gql_client=gql_client,
        mo_person=mo_person,
        sd_person=sd_person,
        dry_run=dry_run,
    )

    logger.info(
        "Done syncing person!", institution_identifier=institution_identifier, cpr=cpr
    )
