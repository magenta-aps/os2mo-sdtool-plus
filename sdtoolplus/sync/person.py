# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
from datetime import datetime
from datetime import timedelta
from uuid import UUID

import structlog
from fastramqpi.ramqp.depends import handle_exclusively_decorator
from more_itertools import bucket
from more_itertools import one
from more_itertools import only
from sdclient.client import SDClient

from sdtoolplus.autogenerated_graphql_client import AddressCreateInput
from sdtoolplus.autogenerated_graphql_client import AddressFilter
from sdtoolplus.autogenerated_graphql_client import AddressTerminateInput
from sdtoolplus.autogenerated_graphql_client import ClassFilter
from sdtoolplus.autogenerated_graphql_client import EmployeeFilter
from sdtoolplus.autogenerated_graphql_client import FacetFilter
from sdtoolplus.autogenerated_graphql_client import GetAddressTimelineAddresses
from sdtoolplus.autogenerated_graphql_client import GetPersonTimelineEmployees
from sdtoolplus.autogenerated_graphql_client import RAValidityInput
from sdtoolplus.config import TIMEZONE
from sdtoolplus.config import Mode
from sdtoolplus.config import SDToolPlusSettings
from sdtoolplus.depends import GraphQLClient
from sdtoolplus.exceptions import MoreThanOnePersonError
from sdtoolplus.mo.person import create_person
from sdtoolplus.mo.person import update_person
from sdtoolplus.models import Person
from sdtoolplus.sd.person import get_sd_person
from sdtoolplus.types import CPRNumber

logger = structlog.stdlib.get_logger()


async def _sync_person(
    gql_client: GraphQLClient,
    settings: SDToolPlusSettings,
    sd_person: Person,
    mo_person: GetPersonTimelineEmployees,
) -> None:
    mo_objects = only(mo_person.objects, too_long=MoreThanOnePersonError)
    if mo_objects is None:
        person_uuid = await create_person(
            gql_client=gql_client,
            cpr=sd_person.cpr,
            givenname=sd_person.given_name,
            lastname=sd_person.surname,
        )
    elif (
        len(mo_objects.validities) > 1
        or one(mo_objects.validities).given_name != sd_person.given_name
        or one(mo_objects.validities).surname != sd_person.surname
    ):
        person_uuid = one(mo_person.objects).uuid
        await update_person(
            gql_client=gql_client,
            uuid=person_uuid,
            start=datetime.today(),
            person=sd_person,
        )
    else:
        # No changes to person
        person_uuid = one(mo_person.objects).uuid

    # Sync person addresses (postal address, emails and phone numbers)
    await _sync_person_addresses(
        gql_client=gql_client,
        settings=settings,
        person_uuid=person_uuid,
        sd_person=sd_person,
    )


async def _sync_person_addresses(
    gql_client: GraphQLClient,
    settings: SDToolPlusSettings,
    person_uuid: UUID,
    sd_person: Person,
) -> None:
    """Persons are not temporal objects in SD and are handled differently than org units and engagements.
    Instead of the full timeline checks we only check the data from `now` to infinity.
    """
    # TODO: Cache this result as it rarely changes
    address_types_res = await gql_client.get_class(
        class_filter=ClassFilter(facet_user_keys=["employee_address_type"])
    )

    address_types = bucket(
        address_types_res.objects,
        key=lambda obj: obj.current.user_key if obj.current else None,
    )

    await _handle_address(
        gql_client,
        sd_person.emails,
        person_uuid,
        one(address_types["engagement_email"]).uuid,
    )
    await _handle_address(
        gql_client,
        sd_person.phone_numbers,
        person_uuid,
        one(address_types["engagement_telefon"]).uuid,
    )
    if settings.mode == Mode.REGION:
        # The address type "engagement_telefon_anden" is a left over from the APOS
        # import, but we need to clean up these addresses as they will be converted to
        # "engagement_telefon" addresses during person sync.
        await _handle_address(
            gql_client,
            sd_person.phone_numbers,
            person_uuid,
            one(address_types["engagement_telefon_anden"]).uuid,
        )
    # TODO: Addresses should have the scope DAR, but this is not the case everywhere right now.
    await _handle_address(
        gql_client,
        [sd_person.address] if sd_person.address is not None else [],
        person_uuid,
        one(address_types["AdresseSDEmployee"]).uuid,
    )


def _find_address_actions(
    mo_addresses: GetAddressTimelineAddresses, desired_addresses: list[str]
) -> tuple[set[str], set[UUID]]:
    terminate: set[UUID] = set()
    existing: set[str] = set()
    if not mo_addresses.objects:
        return set(desired_addresses), terminate
    for address in mo_addresses.objects:
        # For each address check that there is only one validity,
        # that the wanted value exists in MO and in the correct timeframe
        if (
            len(address.validities) > 1
            or one(address.validities).value not in desired_addresses
            or one(address.validities).value in existing
            or one(address.validities).validity.from_ > datetime.now(tz=TIMEZONE)
            or one(address.validities).validity.to is not None
        ):
            # If any of the above reasons are met we terminate the address
            terminate.add(address.uuid)
        else:
            # If not it is because it exists in MO
            existing.add(one(address.validities).value)

    # Create any address from desired_addresses not in MO yet.
    create = {c for c in desired_addresses if c not in existing}
    return create, terminate


async def _handle_address(
    gql_client: GraphQLClient,
    desired_addresses: list[str],
    person_uuid: UUID,
    address_type_uuid: UUID,
):
    mo_person_addresses = await gql_client.get_address_timeline(
        input=AddressFilter(
            employee=EmployeeFilter(uuids=[person_uuid]),
            address_type=ClassFilter(uuids=[address_type_uuid]),
            from_date=datetime.now(tz=TIMEZONE),
            to_date=None,
        )
    )
    create, terminate = _find_address_actions(mo_person_addresses, desired_addresses)
    # TODO: cache this as it _never_ changes.
    visibility_internal = await gql_client.get_class(
        class_filter=ClassFilter(
            facet=FacetFilter(user_keys=["visibility"]), scope=["INTERNAL"]
        )
    )
    visibility_uuid = one(visibility_internal.objects).uuid

    # Check for new emails:
    for value in create:
        logger.info(
            "Create new address",
            value=value,
            person=person_uuid,
            address_type_uuid=address_type_uuid,
        )
        await gql_client.create_address(
            input=AddressCreateInput(
                person=person_uuid,
                validity=RAValidityInput(from_=datetime.now(tz=TIMEZONE)),
                value=value,
                address_type=address_type_uuid,
                visibility=visibility_uuid,
            )
        )
    # Check for removed emails
    for address_uuid in terminate:
        logger.info("terminate address", person=person_uuid)
        await gql_client.terminate_address(
            AddressTerminateInput(
                uuid=address_uuid,
                to=datetime.now(tz=TIMEZONE).replace(
                    hour=0, minute=0, second=0, microsecond=0
                )
                - timedelta(days=1),
            )
        )


@handle_exclusively_decorator(
    key=lambda sd_client, gql_client, institution_identifier, cpr, dry_run=False: cpr
)
async def sync_person(
    sd_client: SDClient,
    gql_client: GraphQLClient,
    settings: SDToolPlusSettings,
    institution_identifier: str,
    cpr: str,
) -> None:
    logger.info(
        "Sync person",
        inst_id=institution_identifier,
        cpr=cpr,
    )

    if cpr.endswith("0000"):
        logger.warning(
            "Skipping person since CPR ends with 0000",
            institution_identifier=institution_identifier,
            cpr=cpr,
        )
        return

    sd_person = await get_sd_person(
        sd_client=sd_client,
        institution_identifier=institution_identifier,
        cpr=cpr,
        effective_date=datetime.today(),
    )

    mo_person = await gql_client.get_person_timeline(
        filter=EmployeeFilter(
            cpr_numbers=[CPRNumber(cpr)],
            from_date=datetime.now(tz=TIMEZONE),
            to_date=None,
        )
    )
    logger.debug("MO person", mo_person=mo_person.dict())

    await _sync_person(
        gql_client=gql_client,
        settings=settings,
        mo_person=mo_person,
        sd_person=sd_person,
    )

    logger.info(
        "Done syncing person!", institution_identifier=institution_identifier, cpr=cpr
    )
