# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
from datetime import datetime
from enum import Enum
from typing import cast
from uuid import UUID

import structlog
from fastramqpi.ramqp.depends import handle_exclusively_decorator
from more_itertools import first
from more_itertools import one
from more_itertools import only
from sdclient.client import SDClient

from sdtoolplus.autogenerated_graphql_client import AddressFilter
from sdtoolplus.autogenerated_graphql_client import ClassFilter
from sdtoolplus.autogenerated_graphql_client import EmployeeFilter
from sdtoolplus.autogenerated_graphql_client import EngagementFilter
from sdtoolplus.autogenerated_graphql_client import GetPersonTimelineEmployees
from sdtoolplus.config import TIMEZONE
from sdtoolplus.config import SDToolPlusSettings
from sdtoolplus.depends import GraphQLClient
from sdtoolplus.exceptions import MoreThanOneEngagementError
from sdtoolplus.exceptions import MoreThanOnePersonError
from sdtoolplus.mo.person import create_address
from sdtoolplus.mo.person import create_person
from sdtoolplus.mo.person import terminate_address
from sdtoolplus.mo.person import update_address
from sdtoolplus.mo.person import update_person
from sdtoolplus.mo.timelines.common import get_class
from sdtoolplus.mo.timelines.engagement import get_engagement_filter
from sdtoolplus.models import EngagementAddresses
from sdtoolplus.models import Person
from sdtoolplus.sd.person import get_sd_person
from sdtoolplus.sync.common import prefix_eng_user_key
from sdtoolplus.types import CPRNumber

logger = structlog.stdlib.get_logger()


class PersonEngagementAddressType(Enum):
    phone = "telefon"
    email = "email"


async def _sync_address(
    gql_client: GraphQLClient,
    person_uuid: UUID,
    sd_address: str | None,
    address_type_uuid: UUID,
    visibility_uuid: UUID,
    engagement_uuid: UUID | None = None,
) -> None:
    logger.info(
        "Syncing address",
        person_uuid=str(person_uuid),
        sd_address=sd_address,
    )

    now = datetime.now(tz=TIMEZONE)

    address_filter = AddressFilter(
        employee=EmployeeFilter(uuids=[person_uuid]),
        address_type=ClassFilter(uuids=[address_type_uuid]),
        from_date=now,
        to_date=None,
    )
    if engagement_uuid is not None:
        address_filter = AddressFilter(
            employee=EmployeeFilter(uuids=[person_uuid]),
            address_type=ClassFilter(uuids=[address_type_uuid]),
            engagement=EngagementFilter(uuids=[engagement_uuid]),
            from_date=now,
            to_date=None,
        )

    mo_addresses = await gql_client.get_address_timeline(address_filter)
    mo_address = first(mo_addresses.objects, default=None)

    if sd_address is None and mo_address is None:
        return

    # There can only be one of each address type. If there is more than one,
    # terminate all but the first
    for term_address in mo_addresses.objects[1:]:
        await terminate_address(gql_client, term_address.uuid, now)

    # Terminate the address if it is found in MO, but not in SD
    if sd_address is None and mo_address is not None:
        await terminate_address(gql_client, mo_address.uuid, now)
        return

    # Create the address if it is found in SD, but not in MO
    if sd_address is not None and mo_address is None:
        await create_address(
            gql_client=gql_client,
            person_uuid=person_uuid,
            value=sd_address,
            from_=now,
            visibility_uuid=visibility_uuid,
            address_type_uuid=address_type_uuid,
            engagement_uuid=engagement_uuid,
        )
        return

    assert sd_address is not None
    assert mo_address is not None

    # Update existing address
    addr_validity = first(mo_address.validities)
    if not (
        sd_address == addr_validity.value
        and addr_validity.validity.from_ <= now
        and addr_validity.validity.to is None
    ):
        await update_address(
            address_uuid=mo_address.uuid,
            gql_client=gql_client,
            person_uuid=person_uuid,
            value=sd_address,
            from_=now,
            visibility_uuid=visibility_uuid,
            address_type_uuid=address_type_uuid,
            engagement_uuid=engagement_uuid,
        )

    logger.info("Done syncing person address", person_uuid=str(person_uuid))


async def _sync_engagement_addresses(
    gql_client: GraphQLClient,
    settings: SDToolPlusSettings,
    person_uuid: UUID,
    engagement_addresses: list[EngagementAddresses],
    visibility_uuid: UUID,
    address_type: PersonEngagementAddressType,
) -> None:
    logger.info(
        "Syncing engagement addresses",
        person_uuid=str(person_uuid),
        engagement_addresses=[addr.dict() for addr in engagement_addresses],
    )

    for eng_address in engagement_addresses:
        eng_user_key = prefix_eng_user_key(
            settings=settings,
            user_key=eng_address.engagement.employment_identifier,
            inst_id=eng_address.engagement.institution_identifier,
        )

        engagement_timeline = await gql_client.get_engagement_timeline(
            get_engagement_filter(
                person=person_uuid, user_key=eng_user_key, from_date=None, to_date=None
            )
        )

        object_ = only(engagement_timeline.objects, too_long=MoreThanOneEngagementError)
        if object_ is None:
            logger.info(
                "Cannot sync engagement address since engagement not found",
                person_uuid=str(person_uuid),
                user_key=eng_user_key,
            )
            continue
        engagement_uuid = object_.uuid

        eng_address1_type_uuid = await get_class(
            gql_client=gql_client,
            facet_user_key="employee_address_type",
            class_user_key=f"engagement_{address_type.value}",
        )

        await _sync_address(
            gql_client=gql_client,
            person_uuid=person_uuid,
            sd_address=eng_address.address1,
            address_type_uuid=eng_address1_type_uuid,
            visibility_uuid=visibility_uuid,
            engagement_uuid=engagement_uuid,
        )

        eng_address2_type_uuid = await get_class(
            gql_client=gql_client,
            facet_user_key="employee_address_type",
            class_user_key=f"engagement_{address_type.value}_anden",
        )

        await _sync_address(
            gql_client=gql_client,
            person_uuid=person_uuid,
            sd_address=eng_address.address2,
            address_type_uuid=eng_address2_type_uuid,
            visibility_uuid=visibility_uuid,
            engagement_uuid=engagement_uuid,
        )


async def _sync_addresses(
    gql_client: GraphQLClient,
    settings: SDToolPlusSettings,
    person_uuid: UUID,
    sd_person: Person,
) -> None:
    logger.info("Syncing person addresses", person_uuid=str(person_uuid))

    visibility_uuid = await get_class(
        gql_client=gql_client,
        facet_user_key="visibility",
        class_user_key="Public",
    )

    # Person phone 1
    await _sync_address(
        gql_client=gql_client,
        person_uuid=person_uuid,
        sd_address=sd_person.person_phone_number1,
        address_type_uuid=await get_class(
            gql_client=gql_client,
            facet_user_key="employee_address_type",
            class_user_key="person_telefon",
        ),
        visibility_uuid=visibility_uuid,
    )

    # Person phone 2
    await _sync_address(
        gql_client=gql_client,
        person_uuid=person_uuid,
        sd_address=sd_person.person_phone_number2,
        address_type_uuid=await get_class(
            gql_client=gql_client,
            facet_user_key="employee_address_type",
            class_user_key="person_telefon_anden",
        ),
        visibility_uuid=visibility_uuid,
    )

    # Person email 1
    await _sync_address(
        gql_client=gql_client,
        person_uuid=person_uuid,
        sd_address=sd_person.person_email1,
        address_type_uuid=await get_class(
            gql_client=gql_client,
            facet_user_key="employee_address_type",
            class_user_key="person_email",
        ),
        visibility_uuid=visibility_uuid,
    )

    # Person email 2
    await _sync_address(
        gql_client=gql_client,
        person_uuid=person_uuid,
        sd_address=sd_person.person_email2,
        address_type_uuid=await get_class(
            gql_client=gql_client,
            facet_user_key="employee_address_type",
            class_user_key="person_email_anden",
        ),
        visibility_uuid=visibility_uuid,
    )

    # Postal address (only present on the SD person object itself)
    await _sync_address(
        gql_client=gql_client,
        person_uuid=person_uuid,
        sd_address=sd_person.address,
        address_type_uuid=await get_class(
            gql_client=gql_client,
            facet_user_key="employee_address_type",
            class_user_key="AdresseSDEmployee",
        ),
        visibility_uuid=visibility_uuid,
    )

    # Engagement phone numbers
    await _sync_engagement_addresses(
        gql_client=gql_client,
        settings=settings,
        person_uuid=person_uuid,
        engagement_addresses=sd_person.engagement_phone_numbers,
        visibility_uuid=visibility_uuid,
        address_type=PersonEngagementAddressType.phone,
    )

    # Engagement phone numbers
    await _sync_engagement_addresses(
        gql_client=gql_client,
        settings=settings,
        person_uuid=person_uuid,
        engagement_addresses=sd_person.engagement_emails,
        visibility_uuid=visibility_uuid,
        address_type=PersonEngagementAddressType.email,
    )

    logger.info("Done syncing person addresses", person_uuid=str(person_uuid))


async def _sync_person(
    gql_client: GraphQLClient,
    sd_person: Person,
    mo_person: GetPersonTimelineEmployees,
) -> UUID:
    mo_objects = only(mo_person.objects, too_long=MoreThanOnePersonError)
    if mo_objects is None:
        person_uuid = await create_person(
            gql_client=gql_client,
            cpr=sd_person.cpr,
            givenname=sd_person.given_name,
            lastname=sd_person.surname,
        )
        return person_uuid
    mo_validities = mo_objects.validities

    if (
        len(mo_validities) > 1
        or one(mo_validities).given_name != sd_person.given_name
        or one(mo_validities).surname != sd_person.surname
    ):
        await update_person(
            gql_client=gql_client,
            uuid=one(mo_person.objects).uuid,
            start=datetime.today(),
            person=sd_person,
        )

    return mo_objects.uuid


@handle_exclusively_decorator(
    key=lambda sd_client, gql_client, settings, institution_identifier, cpr: cpr
)
async def sync_person(
    sd_client: SDClient,
    gql_client: GraphQLClient,
    settings: SDToolPlusSettings,
    institution_identifier: str,
    cpr: str,
) -> None:
    logger.info(
        "Sync person",
        inst_id=institution_identifier,
        cpr=cpr,
    )

    if cpr.endswith("0000"):
        logger.warning(
            "Skipping person since CPR ends with 0000",
            institution_identifier=institution_identifier,
            cpr=cpr,
        )
        return

    sd_person = await get_sd_person(
        sd_client=sd_client,
        institution_identifier=institution_identifier,
        cpr=cpr,
        effective_date=datetime.today(),
    )

    mo_person = await gql_client.get_person_timeline(
        filter=EmployeeFilter(
            cpr_numbers=[cast(CPRNumber, cpr)], from_date=datetime.today(), to_date=None
        )
    )
    logger.debug("MO person", mo_person=mo_person.dict())

    person_uuid = await _sync_person(
        gql_client=gql_client,
        mo_person=mo_person,
        sd_person=sd_person,
    )

    logger.info(
        "Done syncing person!", institution_identifier=institution_identifier, cpr=cpr
    )

    if settings.enable_person_address_sync:
        await _sync_addresses(
            gql_client=gql_client,
            settings=settings,
            person_uuid=person_uuid,
            sd_person=sd_person,
        )
