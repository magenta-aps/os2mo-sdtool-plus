# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
from datetime import datetime
from datetime import timedelta
from uuid import UUID

import structlog
from more_itertools import one
from more_itertools import only

from sdtoolplus.autogenerated_graphql_client import AssociationCreateInput
from sdtoolplus.autogenerated_graphql_client import AssociationFilter
from sdtoolplus.autogenerated_graphql_client import AssociationTerminateInput
from sdtoolplus.autogenerated_graphql_client import AssociationUpdateInput
from sdtoolplus.autogenerated_graphql_client import EmployeeFilter
from sdtoolplus.depends import GraphQLClient
from sdtoolplus.exceptions import MoreThanOneAssociationError
from sdtoolplus.mo.timelines.common import get_patch_validity
from sdtoolplus.mo.timelines.common import mo_end_to_timeline_end
from sdtoolplus.mo.timelines.common import timeline_interval_to_mo_validity
from sdtoolplus.models import Active
from sdtoolplus.models import AssociationTimeline
from sdtoolplus.models import EngagementSDUnit
from sdtoolplus.models import Timeline
from sdtoolplus.models import combine_intervals

logger = structlog.stdlib.get_logger()


def get_association_filter(
    person: UUID, user_key: str, from_date: datetime | None, to_date: datetime | None
) -> AssociationFilter:
    return AssociationFilter(
        # TODO: check if association_type_user_keys is municipality dependent
        association_type_user_keys=["SD-medarbejder"],
        employee=EmployeeFilter(uuids=[person]),
        # NOTE: users keys are assumed unique and static. If they change we will
        # risk creating duplicate associations. Ideally, we should attach the
        # association to the engagement UUID, but in order to be backwards
        # compatible with the old SD-integration, we will use the user_key.
        user_keys=[user_key],
        from_date=from_date,
        to_date=to_date,
    )


async def get_association_timeline(
    gql_client: GraphQLClient,
    person: UUID,
    user_key: str,
) -> AssociationTimeline:
    gql_timeline = await gql_client.get_association_timeline(
        get_association_filter(
            person=person, user_key=user_key, from_date=None, to_date=None
        )
    )

    objects = gql_timeline.objects

    if not objects:
        return AssociationTimeline()

    validities = one(objects, too_long=MoreThanOneAssociationError).validities

    active_intervals = tuple(
        Active(
            start=obj.validity.from_,
            end=mo_end_to_timeline_end(obj.validity.to),
            value=True,
        )
        for obj in validities
    )

    unit_intervals = tuple(
        EngagementSDUnit(
            start=obj.validity.from_,
            end=mo_end_to_timeline_end(obj.validity.to),
            value=obj.org_unit_uuid,
        )
        for obj in validities
    )

    timeline = AssociationTimeline(
        association_active=Timeline[Active](
            intervals=combine_intervals(active_intervals)
        ),
        association_unit=Timeline[EngagementSDUnit](
            intervals=combine_intervals(unit_intervals)
        ),
    )
    logger.info("MO association timeline", timeline=timeline.dict())

    return timeline


async def create_association(
    gql_client: GraphQLClient,
    person: UUID,
    user_key: str,
    sd_association_timeline: AssociationTimeline,
    start: datetime,
    end: datetime,
    association_type: UUID,
    dry_run: bool = False,
) -> None:
    logger.info(
        "Create association",
        person=str(person),
        user_key=user_key,
        start=start,
        end=end,
    )

    payload = AssociationCreateInput(
        user_key=user_key,
        person=person,
        org_unit=sd_association_timeline.association_unit.entity_at(start).value,
        association_type=association_type,
        validity=timeline_interval_to_mo_validity(start, end),
    )
    logger.info("Create association payload", payload=payload.dict())

    if not dry_run:
        await gql_client.create_association(payload)
    logger.info("Association created", person=str(person), user_key=user_key)


async def update_association(
    gql_client: GraphQLClient,
    person: UUID,
    user_key: str,
    sd_association_timeline: AssociationTimeline,
    start: datetime,
    end: datetime,
    association_type: UUID,
    dry_run: bool = False,
) -> None:
    logger.info(
        "Update association",
        person=str(person),
        user_key=user_key,
        start=start,
        end=end,
    )

    mo_validity = timeline_interval_to_mo_validity(start, end)

    association = await gql_client.get_association_timeline(
        get_association_filter(
            person=person, user_key=user_key, from_date=start, to_date=end
        )
    )
    objects = association.objects
    obj = only(objects)

    if obj:
        # The association already exists in this validity period
        for validity in one(objects).validities:
            payload = AssociationUpdateInput(
                uuid=obj.uuid,
                user_key=user_key,
                person=person,
                org_unit=sd_association_timeline.association_unit.entity_at(
                    start
                ).value,
                association_type=association_type,
                validity=get_patch_validity(
                    validity.validity.from_, validity.validity.to, mo_validity
                ),
            )
            logger.info("Update association payload", payload=payload.dict())
            if not dry_run:
                await gql_client.update_association(payload)
            logger.info("Association updated", person=str(person), user_key=user_key)
        return

    # The association does not already exist in this validity period
    association = await gql_client.get_association_timeline(
        get_association_filter(
            person=person, user_key=user_key, from_date=None, to_date=None
        )
    )
    payload = AssociationUpdateInput(
        uuid=one(association.objects).uuid,
        user_key=user_key,
        person=person,
        org_unit=sd_association_timeline.association_unit.entity_at(start).value,
        association_type=association_type,
        validity=mo_validity,
    )
    logger.info("Update association payload", payload=payload.dict())

    if not dry_run:
        await gql_client.update_association(payload)
    logger.info("Association updated", person=str(person), user_key=user_key)


async def terminate_association(
    gql_client: GraphQLClient,
    person: UUID,
    user_key: str,
    start: datetime,
    end: datetime,
    dry_run: bool = False,
) -> None:
    logger.info(
        "Terminate association",
        person=str(person),
        user_key=user_key,
        start=start,
        end=end,
    )

    mo_validity = timeline_interval_to_mo_validity(start, end)

    association = await gql_client.get_association_timeline(
        get_association_filter(
            person=person, user_key=user_key, from_date=None, to_date=None
        )
    )
    association_uuid = one(association.objects).uuid

    if mo_validity.to is not None:
        payload = AssociationTerminateInput(
            uuid=association_uuid, from_=mo_validity.from_, to=mo_validity.to
        )
    else:
        payload = AssociationTerminateInput(
            uuid=association_uuid,
            # Converting from "from" to "to" due to the wierd way terminations in MO work
            to=mo_validity.from_ - timedelta(days=1),
        )
    logger.info("Terminate association payload", payload=payload.dict())

    if not dry_run:
        await gql_client.terminate_association(payload)
    logger.info("Association terminated", person=str(person), user_key=user_key)
