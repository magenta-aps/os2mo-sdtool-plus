# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
from datetime import datetime
from datetime import timedelta
from uuid import UUID

import structlog
from more_itertools import one
from more_itertools import only

from sdtoolplus.autogenerated_graphql_client import ClassFilter
from sdtoolplus.autogenerated_graphql_client import EmployeeFilter
from sdtoolplus.autogenerated_graphql_client import EngagementCreateInput
from sdtoolplus.autogenerated_graphql_client import EngagementFilter
from sdtoolplus.autogenerated_graphql_client import EngagementTerminateInput
from sdtoolplus.autogenerated_graphql_client import EngagementUpdateInput
from sdtoolplus.autogenerated_graphql_client import FacetFilter
from sdtoolplus.config import SDToolPlusSettings
from sdtoolplus.depends import GraphQLClient
from sdtoolplus.exceptions import MoreThanOneEngagementError
from sdtoolplus.mo.timelines.common import get_class_user_key
from sdtoolplus.mo.timelines.common import get_patch_validity
from sdtoolplus.mo.timelines.common import mo_end_to_timeline_end
from sdtoolplus.mo.timelines.common import timeline_interval_to_mo_validity
from sdtoolplus.models import Active
from sdtoolplus.models import EngagementKey
from sdtoolplus.models import EngagementName
from sdtoolplus.models import EngagementSDUnit
from sdtoolplus.models import EngagementTimeline
from sdtoolplus.models import EngagementType
from sdtoolplus.models import EngagementUnit
from sdtoolplus.models import EngagementUnitId
from sdtoolplus.models import EngType
from sdtoolplus.models import Timeline
from sdtoolplus.models import combine_intervals

logger = structlog.stdlib.get_logger()


async def get_engagement_types(gql_client: GraphQLClient) -> dict[EngType, UUID]:
    """
    Get map from engagement type (Enum) to MO engagement type class UUID
    """
    r_eng_types = await gql_client.get_class(
        ClassFilter(
            facet=FacetFilter(user_keys=["engagement_type"]),
            user_keys=[eng_type.value for eng_type in EngType],
        )
    )

    relevant_classes = (
        obj.current for obj in r_eng_types.objects if obj.current is not None
    )

    return {EngType(clazz.user_key): clazz.uuid for clazz in relevant_classes}


async def get_engagement_types_to_process(
    gql_client: GraphQLClient,
    settings: SDToolPlusSettings,
) -> set[UUID]:
    """
    Get a list of the engagement types to process, i.e. the
    engagement types from the ENGAGEMENT_TYPES_TO_PROCESS environment
    variable.
    """
    r_eng_types = await gql_client.get_class(
        ClassFilter(
            facet=FacetFilter(user_keys=["engagement_type"]),
            user_keys=settings.engagement_types_to_process,
        )
    )

    relevant_classes = (
        obj.current for obj in r_eng_types.objects if obj.current is not None
    )

    return set(clazz.uuid for clazz in relevant_classes)


async def get_job_function(
    gql_client: GraphQLClient, job_function_user_key: str
) -> UUID:
    """
    Get the job_function class UUID
    """
    r_job_function = await gql_client.get_class(
        ClassFilter(
            facet=FacetFilter(user_keys=["engagement_job_function"]),
            user_keys=[job_function_user_key],
            # The scope is the JobPositionLevelCode, and employments in SD
            # always refer to JobPositions at level 0.
            scope=["0"],
        )
    )
    try:
        current_job_function = one(r_job_function.objects).current
    except ValueError as error:
        logger.error(
            "Not exactly one class found in MO",
            facet_user_key="engagement_job_function",
            class_user_key=job_function_user_key,
            error=error,
        )
        raise error

    assert current_job_function is not None

    return current_job_function.uuid


def get_engagement_filter(
    person: UUID, user_key: str, from_date: datetime | None, to_date: datetime | None
) -> EngagementFilter:
    return EngagementFilter(
        employee=EmployeeFilter(uuids=[person]),
        user_keys=[user_key],
        from_date=from_date,
        to_date=to_date,
    )


async def get_engagement_timeline(
    gql_client: GraphQLClient,
    person: UUID,
    user_key: str,
) -> EngagementTimeline:
    logger.info("Get MO engagement timeline", person=str(person), emp_id=user_key)

    gql_timeline = await gql_client.get_engagement_timeline(
        get_engagement_filter(
            person=person, user_key=user_key, from_date=None, to_date=None
        )
    )
    objects = gql_timeline.objects

    if not objects:
        return EngagementTimeline()

    object_ = one(objects, too_long=MoreThanOneEngagementError)
    validities = object_.validities

    # Make sure we only look up each class once in MO for this time calculation
    class_uuid_to_user_key: dict[UUID, str] = dict()

    activity_intervals = tuple(
        Active(
            start=obj.validity.from_,
            # TODO (#61435): MOs GraphQL subtracts one day from the validity end dates
            # when reading, compared to what was written.
            end=mo_end_to_timeline_end(obj.validity.to),
            value=True,
        )
        for obj in validities
    )

    key_intervals = []
    for obj in validities:
        job_function_user_key = await get_class_user_key(
            gql_client=gql_client,
            class_uuid=obj.job_function_uuid,
            at=obj.validity.from_,
        )
        key_intervals.append(
            EngagementKey(
                start=obj.validity.from_,
                end=mo_end_to_timeline_end(obj.validity.to),
                value=job_function_user_key,
            )
        )

    name_intervals = tuple(
        EngagementName(
            start=obj.validity.from_,
            end=mo_end_to_timeline_end(obj.validity.to),
            # TODO: introduce name strategy here
            value=obj.extension_1,
        )
        for obj in validities
    )

    unit_intervals = tuple(
        EngagementUnit(
            start=obj.validity.from_,
            end=mo_end_to_timeline_end(obj.validity.to),
            value=obj.org_unit_uuid,
        )
        for obj in validities
    )

    sd_unit_intervals = tuple(
        EngagementSDUnit(
            start=obj.validity.from_,
            end=mo_end_to_timeline_end(obj.validity.to),
            value=obj.extension_5,
        )
        for obj in validities
    )

    unit_id_intervals = tuple(
        EngagementUnitId(
            start=obj.validity.from_,
            end=mo_end_to_timeline_end(obj.validity.to),
            value=obj.extension_4,
        )
        for obj in validities
    )

    type_intervals = []
    for obj in validities:
        type_user_key = class_uuid_to_user_key.get(obj.engagement_type_uuid)
        if type_user_key is None:
            type_user_key = await get_class_user_key(
                gql_client=gql_client, class_uuid=obj.engagement_type_uuid
            )
        type_intervals.append(
            EngagementType(
                start=obj.validity.from_,
                end=mo_end_to_timeline_end(obj.validity.to),
                value=EngType(type_user_key),
            )
        )

    timeline = EngagementTimeline(
        eng_active=Timeline[Active](intervals=combine_intervals(activity_intervals)),
        eng_key=Timeline[EngagementKey](
            intervals=combine_intervals(tuple(key_intervals))
        ),
        eng_name=Timeline[EngagementName](intervals=combine_intervals(name_intervals)),
        eng_unit=Timeline[EngagementUnit](intervals=combine_intervals(unit_intervals)),
        eng_sd_unit=Timeline[EngagementSDUnit](
            intervals=combine_intervals(sd_unit_intervals)
        ),
        eng_unit_id=Timeline[EngagementUnitId](
            intervals=combine_intervals(unit_id_intervals)
        ),
        eng_type=Timeline[EngagementType](
            intervals=combine_intervals(tuple(type_intervals))
        ),
    )
    logger.debug("MO engagement timeline", timeline=timeline.dict())

    return timeline


async def create_engagement(
    gql_client: GraphQLClient,
    person: UUID,
    user_key: str,
    start: datetime,
    end: datetime,
    desired_eng_timeline: EngagementTimeline,
    eng_types: dict[EngType, UUID],
    dry_run: bool = False,
) -> None:
    logger.info("Creating engagement", person=str(person), emp_id=user_key)
    logger.debug(
        "Creating engagement",
        start=start,
        end=end,
        desired_eng_timeline=desired_eng_timeline.dict(),
    )

    # Get the job_function
    job_function_uuid = await get_job_function(
        gql_client=gql_client,
        job_function_user_key=str(desired_eng_timeline.eng_key.entity_at(start).value),
    )

    payload = EngagementCreateInput(
        user_key=user_key,
        validity=timeline_interval_to_mo_validity(start, end),
        extension_1=desired_eng_timeline.eng_name.entity_at(start).value,
        extension_4=desired_eng_timeline.eng_unit_id.entity_at(start).value,
        extension_5=str(desired_eng_timeline.eng_sd_unit.entity_at(start).value),
        person=person,
        org_unit=desired_eng_timeline.eng_unit.entity_at(start).value,
        engagement_type=eng_types[
            desired_eng_timeline.eng_type.entity_at(start).value  # type: ignore
        ],
        # TODO: introduce job_function strategy
        job_function=job_function_uuid,
    )
    logger.debug("Create engagement payload", payload=payload.dict())
    if not dry_run:
        await gql_client.create_engagement(payload)
    logger.debug("Engagement created", person=str(person), emp_id=user_key)


async def update_engagement(
    gql_client: GraphQLClient,
    person: UUID,
    user_key: str,
    start: datetime,
    end: datetime,
    desired_eng_timeline: EngagementTimeline,
    eng_types: dict[EngType, UUID],
    dry_run: bool = False,
) -> None:
    logger.info("Update engagement", person=str(person), emp_id=user_key)
    logger.debug(
        "Update engagement",
        start=start,
        end=end,
        desired_eng_timeline=desired_eng_timeline.dict(),
    )

    # Get the job_function
    job_function_uuid = await get_job_function(
        gql_client=gql_client,
        job_function_user_key=str(desired_eng_timeline.eng_key.entity_at(start).value),
    )

    mo_validity = timeline_interval_to_mo_validity(start, end)

    eng = await gql_client.get_engagement_timeline(
        get_engagement_filter(
            person=person, user_key=user_key, from_date=start, to_date=end
        )
    )
    obj = only(eng.objects)

    if obj:
        # The engagement already exists in this validity period
        for validity in one(eng.objects).validities:
            eng_name = desired_eng_timeline.eng_name.entity_at(start).value
            payload = EngagementUpdateInput(
                uuid=obj.uuid,
                user_key=user_key,
                primary=validity.primary_uuid,
                validity=get_patch_validity(
                    validity.validity.from_, validity.validity.to, mo_validity
                ),
                # The empty string will be converted to null in the LoRa DB. Update
                # logic when https://redmine.magenta.dk/issues/65028 has been fixed.
                extension_1=eng_name if eng_name is not None else "",
                extension_2=validity.extension_2,
                extension_3=validity.extension_3,
                extension_4=desired_eng_timeline.eng_unit_id.entity_at(start).value,
                extension_5=str(
                    desired_eng_timeline.eng_sd_unit.entity_at(start).value
                ),
                extension_6=validity.extension_6,
                extension_7=validity.extension_7,
                extension_8=validity.extension_8,
                extension_9=validity.extension_9,
                extension_10=validity.extension_10,
                person=person,
                org_unit=desired_eng_timeline.eng_unit.entity_at(start).value,
                engagement_type=eng_types[
                    desired_eng_timeline.eng_type.entity_at(start).value  # type: ignore
                ],
                job_function=job_function_uuid,
            )
            logger.debug(
                "Update engagement in validity interval",
                payload=payload.dict(),
                validity=validity,
            )
            if not dry_run:
                await gql_client.update_engagement(payload)
            logger.debug("Engagement updated", person=str(person), emp_id=user_key)
        return

    # The engagement does not already exist in this validity period
    eng = await gql_client.get_engagement_timeline(
        get_engagement_filter(
            person=person, user_key=user_key, from_date=None, to_date=None
        )
    )
    payload = EngagementUpdateInput(
        uuid=one(eng.objects).uuid,
        user_key=user_key,
        validity=mo_validity,
        # TODO: introduce extention_1 strategy
        extension_1=desired_eng_timeline.eng_name.entity_at(start).value,
        extension_4=desired_eng_timeline.eng_unit_id.entity_at(start).value,
        extension_5=str(desired_eng_timeline.eng_sd_unit.entity_at(start).value),
        person=person,
        org_unit=desired_eng_timeline.eng_unit.entity_at(start).value,
        engagement_type=eng_types[desired_eng_timeline.eng_type.entity_at(start).value],  # type: ignore
        job_function=job_function_uuid,
    )
    logger.debug(
        "Update engagement in interval", payload=payload.dict(), mo_validity=mo_validity
    )
    if not dry_run:
        await gql_client.update_engagement(payload)
    logger.debug("Engagement updated", person=str(person), emp_id=user_key)


async def terminate_engagement(
    gql_client: GraphQLClient,
    person: UUID,
    user_key: str,
    start: datetime,
    end: datetime,
    dry_run: bool = False,
) -> None:
    logger.info(
        "Terminate engagement",
        person=str(person),
        user_key=user_key,
        start=start,
        end=end,
    )

    mo_validity = timeline_interval_to_mo_validity(start, end)

    eng = await gql_client.get_engagement_timeline(
        get_engagement_filter(
            person=person, user_key=user_key, from_date=None, to_date=None
        )
    )
    try:
        eng_uuid = one(eng.objects).uuid
    except ValueError:
        # This can happen if the SD engagement active timeline only contains
        # status 8 intervals
        logger.warning(
            "Cannot terminate engagement since it is not found in MO",
            person=str(person),
            user_key=user_key,
        )
        return

    if mo_validity.to is not None:
        payload = EngagementTerminateInput(
            uuid=eng_uuid, from_=mo_validity.from_, to=mo_validity.to
        )
    else:
        payload = EngagementTerminateInput(
            uuid=eng_uuid,
            # Converting from "from" to "to" due to the wierd way terminations in MO work
            to=mo_validity.from_ - timedelta(days=1),
        )
    logger.debug("Terminate engagement", payload=payload.dict())

    if not dry_run:
        await gql_client.terminate_engagement(payload)
    logger.debug("Engagement terminated", person=str(person), user_key=user_key)
