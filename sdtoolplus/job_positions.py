# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
import asyncio
from collections.abc import Iterator
from dataclasses import dataclass
from dataclasses import field
from datetime import datetime
from datetime import time
from uuid import UUID
from uuid import uuid4

import structlog
from more_itertools import one
from more_itertools import only
from sdclient.client import SDClient
from sdclient.requests import GetProfessionRequest
from sdclient.responses import ProfessionObj

from sdtoolplus.autogenerated_graphql_client.input_types import ClassCreateInput
from sdtoolplus.autogenerated_graphql_client.input_types import ClassFilter
from sdtoolplus.autogenerated_graphql_client.input_types import ClassUpdateInput
from sdtoolplus.autogenerated_graphql_client.input_types import FacetFilter
from sdtoolplus.autogenerated_graphql_client.input_types import ValidityInput
from sdtoolplus.config import TIMEZONE
from sdtoolplus.depends import GraphQLClient

logger = structlog.stdlib.get_logger()


@dataclass
class Class:
    """Comparable Class model."""

    uuid: UUID = field(
        compare=False,  # class UUIDs are not imported from SD
    )
    user_key: str
    name: str
    scope: str | None
    parent: UUID | None


async def get_actual(
    graphql_client: GraphQLClient,
    mo_engagement_job_function_uuid: UUID,
    sd_profession: ProfessionObj,
) -> Class | None:
    """Get class(es) actually in MO."""
    mo_classes = await graphql_client.get_class(
        ClassFilter(
            facet=FacetFilter(uuids=[mo_engagement_job_function_uuid]),
            scope=[sd_profession.JobPositionLevelCode],
            user_keys=[sd_profession.JobPositionIdentifier],
        )
    )
    # (scope, user_key) is assumed unique (and stable)
    mo_class = only(mo_classes.objects)
    if mo_class is None:
        return None
    assert mo_class.current is not None
    return Class(
        uuid=mo_class.uuid,
        user_key=mo_class.current.user_key,
        name=mo_class.current.name,
        scope=mo_class.current.scope,
        parent=(
            mo_class.current.parent.uuid
            if mo_class.current.parent is not None
            else None
        ),
    )


async def get_desired(
    graphql_client: GraphQLClient,
    mo_engagement_job_function_uuid: UUID,
    sd_parent: ProfessionObj | None,
    sd_profession: ProfessionObj,
) -> Class:
    """Construct desired class based on SD profession."""
    # A name is required at level 0. It can be empty at other levels.
    assert sd_profession.JobPositionName is not None

    if sd_parent is None:
        mo_parent_uuid = None
    else:
        mo_parents = await graphql_client.get_class(
            ClassFilter(
                facet=FacetFilter(uuids=[mo_engagement_job_function_uuid]),
                scope=[sd_parent.JobPositionLevelCode],
                user_keys=[sd_parent.JobPositionIdentifier],
            )
        )
        # The parent should exist in MO since we are creating classes in a
        # breadth-first manner.
        mo_parent = one(mo_parents.objects)
        assert mo_parent.current is not None
        mo_parent_uuid = mo_parent.current.uuid

    # The JobPositionIdentifier is guaranteed unique *within* each level, not
    # across levels. An employment always refers to a profession on level 0 in
    # SD. Level 1-3 are groupings of codes that can be used for statistics or
    # budgeting, e.g. "all nurses" or "all doctors".
    # We set user_key=JobPositionIdentifier, scope=JobPositionLevelCode in MO
    # for a (scope, user_key) compound primary key. Engagements should refer to
    # the (0, JobPositionIdentifier) class.
    return Class(
        uuid=uuid4(),  # UUIDs are not imported from SD
        user_key=sd_profession.JobPositionIdentifier,
        name=sd_profession.JobPositionName,
        scope=sd_profession.JobPositionLevelCode,
        parent=mo_parent_uuid,
    )


async def sync(
    graphql_client: GraphQLClient,
    mo_engagement_job_function_uuid: UUID,
    sd_parent: ProfessionObj | None,
    sd_profession: ProfessionObj,
) -> None:
    logger.info(
        "Synchronising job function",
        sd_parent=sd_parent.dict() if sd_parent is not None else None,
        sd_profession=sd_profession.dict(),
    )

    actual = await get_actual(
        graphql_client,
        mo_engagement_job_function_uuid,
        sd_profession,
    )
    desired = await get_desired(
        graphql_client,
        mo_engagement_job_function_uuid,
        sd_parent,
        sd_profession,
    )
    logger.debug(actual=actual, desired=desired)

    if actual == desired:
        logger.info("Already up to date")
        return

    # MO does not support datetimes with a time ðŸ¥²
    class_from = datetime.now(tz=TIMEZONE)
    class_from = datetime.combine(class_from, time.min, class_from.tzinfo)

    # Class is missing; create
    if actual is None:
        create_input = ClassCreateInput(
            uuid=desired.uuid,
            facet_uuid=mo_engagement_job_function_uuid,
            user_key=desired.user_key,
            name=desired.name,
            scope=desired.scope,
            parent_uuid=desired.parent,
            validity=ValidityInput(from_=class_from, to=None),
        )
        logger.info("Creating missing job function", input=create_input)
        await graphql_client.create_class(create_input)
        return

    # Class is incorrect; update
    update_input = ClassUpdateInput(
        uuid=actual.uuid,
        facet_uuid=mo_engagement_job_function_uuid,
        user_key=desired.user_key,
        name=desired.name,
        scope=desired.scope,
        parent_uuid=desired.parent,
        validity=ValidityInput(from_=class_from, to=None),
    )
    logger.info("Updating incorrect job function", input=update_input)
    await graphql_client.update_class(update_input)


def walk(
    parent: ProfessionObj | None, professions: list[ProfessionObj]
) -> Iterator[tuple[ProfessionObj | None, ProfessionObj]]:
    """Yield (parent, profession) pairs."""
    for profession in professions:
        yield parent, profession
        yield from walk(parent=profession, professions=profession.Profession)


async def sync_professions(
    sd_client: SDClient,
    graphql_client: GraphQLClient,
    institution_identifier: str,
) -> None:
    logger.info("Synchronising professions")
    mo_engagement_job_function_uuid = one(
        (await graphql_client.get_facet_uuid("engagement_job_function")).objects
    ).uuid
    sd_professions = await asyncio.to_thread(
        sd_client.get_profession,
        GetProfessionRequest(InstitutionIdentifier=institution_identifier),
    )
    for sd_parent, sd_profession in walk(
        parent=None, professions=sd_professions.Profession
    ):
        await sync(
            graphql_client,
            mo_engagement_job_function_uuid,
            sd_parent,
            sd_profession,
        )
